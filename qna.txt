1. 궁금한 것

인텔리제이
 - 톰캣 서버 재시작 없이 소스 반영 ?
   > 서버 설정 외에 하는 것 있나? 잘 안바뀜
 - STS 와 같이 servlet, context xml 파일 이름을 바꿔주는지 그 외에도 파일 이름 같은거 처리

스프링
 - 스프링 버전은 ?
 - 자바 설정 시 (jsp, html 설정? 두개 다 쓰는지 또는 쓰는 방법?)
 - 부트스트랩 사용하는지 (css)
 - controller - service - dao - mapper 방식 책과 실무가 비슷한지 (패키지 구성이 다른지)
 - Test 코드는 어디까지 작성 하는지 (controller, service, mapper 다? )
 - http - get, post, put,delete? 사용하나?
 - ajax 통신/ form 전송? 자주 사용하는것?



1. RootConfig(applicationContext.xml) 와 ServletConfig(servlet-context.xml) 에서 왜 컴포넌트 스캔을 다르게 설정하는지?

* context 란
Bean의 확장 버전으로, Spring이 Bean을 좀 더 다루기 쉽도록 기능들이 추가된 공간이다.


이유1.
1. 공통 부분(ROOT-Context) == applicationContext
: 모든 서블릿이 공유할 수 있는 Bean들이 모인 공간을 말한다.
DB와 관련된 Repository나, Service 등이 있다.

2. 개별 부분(Servlet-Context) == dispacherServlet
: 서블릿 각자의 Bean들이 모인 공간이다.
웹 앱마다 한개씩 존재하므로, 웹 앱 그 자체를 의미하기도 한다.
이 컨텍스트 내의 Bean들은 서로 공유될 수 없다.
MVC의 Controller(서블릿)이 이에 해당한다.



이유2.
Transaction(ACID - 원자성, 일관성, 격리, 영속성)을 적용하기 위해서.
> 스프링 트랜잭션은 AOP를 이용해서 해당 빈의 proxy를 만들어서 tx가 적용되는 Bean을 바꿔치기한다.
  그럼 원래 @Service(또는 @Transactional) 어노테이션이 붙은 빈은 숨고 tx가 적용된 proxy bean이 @Service가 붙은 bean으로 대치된다.

> 만약 Application Context 와 Servlet Context가 모든 타입의 컴포넌트를 풀 스캔할 경우, tx설정은 Application Context에만 적용되기 때문에
  Application Context 의 @Service는 트랜잭션 적용이 되지만 Servlet Context 의 @Service 는 트랜잭션 적용이 안된다.

> Bean객체는 Servlet Context 가 우선되므로, @Controller가 동작하여 같은 Context 안에서 검색을 하고, @Service가 지정된 bean이 있으므로 이 bean을 사용한다.
  이 @Service가 지정된 bean은 트랜잭션 적용이 안 되어 있어 트랜잭션 처리가 안된다.

* Transaction은 applicationContext 만 동작 하고 servlet Context 에서는 적용안됨



2. DispatcherServlet이 하는 역할은 무엇인가?
- Spring Container (servlet context)를 생성한다.
- 클라이언트의 요청을 Handler(Controller)에 보낸다
  > 1) HandlerMapping, 2) HandlerAdapter (controller), ViewResolver

- Servlet Container 의 역할
- 웹서버와의 통신
- 서블릿 생명주기 관리
- 멀티쓰레드 지원 및 관리

- Servlet-Context
  > Servlet 단위로 생성되는 Context
  > Application Context를 자신의 부모 Context로 사용한다.
    (Servlet Context에 정된 Bean은 Application Context Bean을 사용할 수 있다.)
  > Bean 찾는 순서
    Servlet Context를 먼저 찾고 그 다음 Application Context를 찾는다.
    (같은 bean이 설정 되어 있다면 Servlet에 설정된 bean을 사용.)



2-1. root-context.xml의 역할

- Application Context
  > Web Application 최상단에 있는 Context
  > Spring 에서 BeanFactory를 상속 받고 있는 Context
  > Servlet과 관련 없는 설정을 한다 (@Service, @Mapper, @Configuration)
  > 서로 다른 Servlet에서 공통적으로 공유해서 사용가능
  > Application Context에 정의된 Bean은 Servlet Context에 정의 된 Bean을 사용할수 없다.

- 공통적으로 사용하는 Bean을 등록 (DB)



3. WebConfig(web.xml)이 하는 역할이 무엇인가?
Deployment Descriptor(배포 서술자)
- web.xml (웹 애플리케이션 마다 하나씩만 존재)
- web application의 기본 설정 (WAS가 최초로 구동 될 때 읽음.)
- 스프링 환경 설정 파일 로딩 (dispatcherServlet.xml, root-context.xml)
- Deploy 할 때 Servlet 정보를 매핑 설정한다.
  > Servlet은 웹프로그래밍에서 클라이언트의 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 역할





@Component는 클래스를 빈으로 등록할때 사용
@Component는 Class Level에서, @Bean은 Method Level에서 적용된다.

@Bean은 사용자가 컨트롤 하지 못하는 Class나, 좀 더 유연하게 객체를 생성해서 넘기고 싶을 때 (이를 테면 외부 라이브러리),
@Component는 Class 자체를 빈으로 등록하고 싶을 때, 사용하면 된다고 이해했다.

Bean으로 등록되면
객체를 스프링 컨테이너가 빈으로 활용함



static 변수는 어떠한 인스턴스에서도 동일한 값을 사용해야할 때 사용된다


static method
메소드 앞에 static이 붙으면 static 메소드가 되는데 static이 붙을 경우 main 메소드에서 클래스를 통해 호출이 가능하다.
일반적으로 이러한 static 메소드는 유틸리티 성 메소드 작성에 많이 사용한다.
예를 들어 날짜를 구하거나 포맷을 지정한다던가 하는 반복적이고 형식적 작업을 하는 경우 많이 사용하게 된다.
사용시 주의할 점으로는 static으로 선언된 메소드에서는 인스턴스 변수에 접근할 수 없다는 것이다.
static 메소드에서는 static 변수만 접근이 가능하기 때문에 사용에 유의해야한다.



--------------------------

질문
 - H2 인메모리 DB 테스트 할때 @Test 한번 할때도 데이터가 없어지는지
 -